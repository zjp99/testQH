/*****************************************************************************
 * File generated by HDevelop Version 18.11
 *
 * Do not modify!
 *****************************************************************************/

#include "measure.h"

#include <algorithm>
#include <map>
#include <mutex>
#include <string>

#ifndef __APPLE__
  #include <hdevengine/HDevEngineCpp.h>
#else
  #include <HDevEngineCpp/HDevEngineCpp.h>
#endif

using namespace HalconCpp;
using namespace HDevEngineCpp;

namespace measure {

  std::string sgResourcePath;
  
  bool AddResourcePathToProcedurePath()
  {
    HDevEngineCpp::HDevEngine().AddProcedurePath(sgResourcePath.c_str());
    return true;
  }

  bool LazyInitProcedurePath()
  {
    static std::mutex lock;
    std::unique_lock<std::mutex> locker(lock);
    static const bool init = AddResourcePathToProcedurePath();
    return init;
  }

  void SetResourcePath(const char* resource_path)
  {
    sgResourcePath = resource_path;
    std::replace(sgResourcePath.begin(),sgResourcePath.end(), '\\','/');
    if(sgResourcePath.length() > 0 && sgResourcePath[sgResourcePath.length()-1]!='/')
    {
      sgResourcePath+="/";
    }
    AddResourcePathToProcedurePath();
  }

#ifdef _WIN32
  void SetResourcePath(const wchar_t* resource_path)
  {
    SetResourcePath(resource_path ? HString(resource_path).TextA() : NULL);
  }
#endif

  template <typename T>
  struct ParamHandler
  {
  };

  template <>
  struct ParamHandler<HalconCpp::HTuple>
  {
    static void SetParameter(HDevEngineCpp::HDevProcedureCall& proc,
        const char*                                     name,
        HalconCpp::HTuple const&                        parameter)
    {
      proc.SetInputCtrlParamTuple(name, parameter);
    }

    static HalconCpp::HTuple GetParameter(
        HDevEngineCpp::HDevProcedureCall& proc, const char* name)
    {
      return proc.GetOutputCtrlParamTuple(name);
    }
  };

  template <>
  struct ParamHandler<HalconCpp::HObject>
  {
    static void SetParameter(HDevEngineCpp::HDevProcedureCall& proc,
        const char*                                     name,
        HalconCpp::HObject const&                       parameter)
    {
      proc.SetInputIconicParamObject(name, parameter);
    }

    static HalconCpp::HObject GetParameter(
        HDevEngineCpp::HDevProcedureCall& proc, const char* name)
    {
      return proc.GetOutputIconicParamObject(name);
    }
  };

  template <>
  struct ParamHandler<HalconCpp::HTupleVector>
  {
    static void SetParameter(HDevEngineCpp::HDevProcedureCall& proc,
        const char*                                     name,
        HalconCpp::HTupleVector const&                  parameter)
    {
      proc.SetInputCtrlParamVector(name, parameter);
    }

    static HalconCpp::HTupleVector GetParameter(
        HDevEngineCpp::HDevProcedureCall& proc, const char* name)
    {
      return proc.GetOutputCtrlParamVector(name);
    }
  };

  template <>
  struct ParamHandler<HalconCpp::HObjectVector>
  {
    static void SetParameter(HDevEngineCpp::HDevProcedureCall& proc,
        const char*                                     name,
        HalconCpp::HObjectVector const&                 parameter)
    {
      proc.SetInputIconicParamVector(name, parameter);
    }

    static HalconCpp::HObjectVector GetParameter(
        HDevEngineCpp::HDevProcedureCall& proc, const char* name)
    {
      return proc.GetOutputIconicParamVector(name);
    }
  };


  HDevProgram GetProgram(std::string const& program_file)
  {
    static std::mutex lock;
    static std::map<std::string,HDevProgram> programs;

    std::unique_lock<std::mutex> locker(lock);

    auto prog_iter = programs.find(program_file);
    if(prog_iter != programs.end())
    {
      return prog_iter->second;
    }
    else
    {
      HDevProgram program(program_file.c_str());
      programs[program_file] = program;
      return program;
    }
    return HDevProgram();
  }

  void get_model(
    HalconCpp::HObject const& ModelImage,
    HalconCpp::HTuple const& RowStart,
    HalconCpp::HTuple const& RowEnd,
    HalconCpp::HTuple* result)
  {     
    static HDevEngineCpp::HDevProcedure procedure(GetProgram(sgResourcePath+"measure.hdev"),"get_model");
    HDevEngineCpp::HDevProcedureCall call=procedure;
    ParamHandler<HalconCpp::HObject>::SetParameter(call,"ModelImage",ModelImage);
    ParamHandler<HalconCpp::HTuple>::SetParameter(call,"RowStart",RowStart);
    ParamHandler<HalconCpp::HTuple>::SetParameter(call,"RowEnd",RowEnd);
        
    call.Execute();

    if (result != nullptr)
      * result = ParamHandler<HalconCpp::HTuple>::GetParameter(call,"result");
  }

  void ScrewMeasure2D(
    HalconCpp::HObject const& ModelImage,
    HalconCpp::HObject const& Image,
    HalconCpp::HObject* ImageReducedOutput1,
    HalconCpp::HObject* ImageReducedOutput2,
    HalconCpp::HObject* contoursXLDS,
    HalconCpp::HTuple const& ModeRectangleRow1,
    HalconCpp::HTuple const& ModeRectangleRow2,
    HalconCpp::HTuple const& ModeRectangleRow11,
    HalconCpp::HTuple const& ModeRectangleRow22,
    HalconCpp::HTuple const& modelPath,
    HalconCpp::HTuple* toothHeight,
    HalconCpp::HTuple* toothWidth,
    HalconCpp::HTuple* screwWidth,
    HalconCpp::HTuple* screwAngle,
    HalconCpp::HTuple* result,
    HalconCpp::HTuple* message)
  {     
    static HDevEngineCpp::HDevProcedure procedure(GetProgram(sgResourcePath+"measure.hdev"),"ScrewMeasure2D");
    HDevEngineCpp::HDevProcedureCall call=procedure;
    ParamHandler<HalconCpp::HObject>::SetParameter(call,"ModelImage",ModelImage);
    ParamHandler<HalconCpp::HObject>::SetParameter(call,"Image",Image);
    ParamHandler<HalconCpp::HTuple>::SetParameter(call,"ModeRectangleRow1",ModeRectangleRow1);
    ParamHandler<HalconCpp::HTuple>::SetParameter(call,"ModeRectangleRow2",ModeRectangleRow2);
    ParamHandler<HalconCpp::HTuple>::SetParameter(call,"ModeRectangleRow11",ModeRectangleRow11);
    ParamHandler<HalconCpp::HTuple>::SetParameter(call,"ModeRectangleRow22",ModeRectangleRow22);
    ParamHandler<HalconCpp::HTuple>::SetParameter(call,"modelPath",modelPath);
        
    call.Execute();

    if (ImageReducedOutput1 != nullptr)
      * ImageReducedOutput1 = ParamHandler<HalconCpp::HObject>::GetParameter(call,"ImageReducedOutput1");
    if (ImageReducedOutput2 != nullptr)
      * ImageReducedOutput2 = ParamHandler<HalconCpp::HObject>::GetParameter(call,"ImageReducedOutput2");
    if (contoursXLDS != nullptr)
      * contoursXLDS = ParamHandler<HalconCpp::HObject>::GetParameter(call,"contoursXLDS");
    if (toothHeight != nullptr)
      * toothHeight = ParamHandler<HalconCpp::HTuple>::GetParameter(call,"toothHeight");
    if (toothWidth != nullptr)
      * toothWidth = ParamHandler<HalconCpp::HTuple>::GetParameter(call,"toothWidth");
    if (screwWidth != nullptr)
      * screwWidth = ParamHandler<HalconCpp::HTuple>::GetParameter(call,"screwWidth");
    if (screwAngle != nullptr)
      * screwAngle = ParamHandler<HalconCpp::HTuple>::GetParameter(call,"screwAngle");
    if (result != nullptr)
      * result = ParamHandler<HalconCpp::HTuple>::GetParameter(call,"result");
    if (message != nullptr)
      * message = ParamHandler<HalconCpp::HTuple>::GetParameter(call,"message");
  }

  void softtri(
    HalconCpp::HTuple const& AcqHandle)
  {     
    static HDevEngineCpp::HDevProcedure procedure(GetProgram(sgResourcePath+"measure.hdev"),"softtri");
    HDevEngineCpp::HDevProcedureCall call=procedure;
    ParamHandler<HalconCpp::HTuple>::SetParameter(call,"AcqHandle",AcqHandle);
        
    call.Execute();

  }

};

